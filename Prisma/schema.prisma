// ============================================================================
// KAHADE ESCROW P2P - FULL SCHEMA (JOURNAL-CENTRIC FK) - SECURITY FIRST
// ============================================================================
// Design:
// - Journal-centric FK: All "journal links" live in LedgerJournal via entityId FKs.
// - Entities DO NOT store journalId (prevents dual-FK inconsistency).
// - Ledger is immutable (no soft-delete fields on ledger_*).
// - onDelete: Restrict for financial/audit-critical records.
// - Additional constraints/indexes that Prisma cannot express are documented
//   in the MIGRATION SQL file (run after prisma migrate).
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum Currency {
  IDR
}

enum KYCStatus {
  NONE
  PENDING
  APPROVED
  REJECTED
}

enum InitiatorRole {
  BUYER
  SELLER
}

enum OrderCategory {
  PHYSICAL
  DIGITAL
  SERVICE
}

enum FeePayer {
  BUYER
  SELLER
  SPLIT
}

enum OrderStatus {
  PENDING_ACCEPT
  INVITE_EXPIRED
  WAITING_PAYMENT
  PAYMENT_FAILED
  PAID_IN_ESCROW
  DELIVERED_PROOF_SUBMITTED
  IN_DISPUTE
  REFUND_PROCESSING
  COMPLETED
  CANCELLED
  AUTO_RELEASED
}

enum PaymentProvider {
  XENDIT
}

enum PaymentMethod {
  VA_BCA
  VA_BNI
  VA_MANDIRI
  VA_BRI
  QRIS
  OVO
  DANA
  GOPAY
  LINKAJA
}

enum PaymentStatus {
  PENDING
  PAID
  EXPIRED
  FAILED
}

enum PaymentType {
  DEPOSIT
  ORDER_PAYMENT
}

enum DepositStatus {
  PENDING
  COMPLETED
  FAILED
}

enum WithdrawalStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  PROCESSING
  COMPLETED
  REJECTED
  FAILED
  CANCELLED
}

enum DisputeStatus {
  OPEN
  AWAITING_RESPONSE
  UNDER_REVIEW
  ESCALATED
  RESOLVED
  CANCELLED
}

enum DisputeDecision {
  NONE
  RELEASE_TO_SELLER
  REFUND_TO_BUYER
  PARTIAL_SPLIT
}

enum LedgerAccountType {
  USER_AVAILABLE
  USER_LOCKED
  PLATFORM_REVENUE
  PLATFORM_CLEARING
}

enum JournalType {
  DEPOSIT_CREDIT
  ESCROW_HOLD
  ESCROW_RELEASE
  ESCROW_REFUND
  FEE_CHARGE
  WITHDRAWAL_LOCK
  WITHDRAWAL_RELEASE
  WITHDRAWAL_DEBIT
  DISPUTE_SETTLEMENT
  REFERRAL_REWARD
  PROMO_CREDIT
  ADJUSTMENT
}

enum EscrowHoldStatus {
  ACTIVE
  RELEASED
  REFUNDED
  CANCELLED
}

enum WebhookStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  DEAD_LETTER
}

enum VoucherType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_FEE
}

enum VoucherStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  DEPLETED
}

enum PromoTargetType {
  ALL_USERS
  NEW_USERS
  SPECIFIC_USERS
  KYC_VERIFIED
}

enum ReferralRewardType {
  FIXED_AMOUNT
  PERCENTAGE_OF_FIRST_TRANSACTION
  TIERED
}

enum ReferralRewardStatus {
  PENDING
  PROCESSING
  COMPLETED
  EXPIRED
  FAILED
}

enum ReferralStatus {
  PENDING
  COMPLETED
  EXPIRED
  CANCELLED
}

enum ActivityType {
  LOGIN
  LOGIN_FAILED
  LOGOUT
  PROFILE_UPDATE
  PASSWORD_CHANGE
  MFA_ENABLED
  MFA_DISABLED
  MFA_FAILED
  KYC_SUBMITTED
  DEPOSIT_INITIATED
  WITHDRAWAL_REQUESTED
  ORDER_CREATED
  ORDER_ACCEPTED
  ORDER_PAID
  ORDER_COMPLETED
  DISPUTE_OPENED
  RATING_SUBMITTED
  BANK_ACCOUNT_ADDED
  BANK_ACCOUNT_REMOVED
  VOUCHER_REDEEMED
  REFERRAL_SENT
  PASSWORD_RESET_REQUESTED
}

enum ScheduledJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================================================
// CORE USER & AUTH MODELS
// ============================================================================

model User {
  id                String    @id @default(uuid())
  username          String    @unique
  email             String    @unique
  phone             String?
  passwordHash      String    @map("password_hash")

  // Account security
  passwordUpdatedAt DateTime? @map("password_updated_at")
  lastLoginAt       DateTime? @map("last_login_at")
  failedLoginCount  Int       @default(0) @map("failed_login_count")
  lockedUntil       DateTime? @map("locked_until")

  // MFA (store encrypted secret; never plaintext)
  mfaEnabled        Boolean   @default(false) @map("mfa_enabled")
  totpSecretEnc     String?   @map("totp_secret_enc") @db.Text
  backupCodesHash   Json?     @map("backup_codes_hash")

  emailVerifiedAt   DateTime? @map("email_verified_at")
  kycStatus         KYCStatus @default(NONE) @map("kyc_status")
  reputationScore   Decimal   @default(0) @db.Decimal(3, 2)
  totalTransactions Int       @default(0) @map("total_transactions")
  isAdmin           Boolean   @default(false) @map("is_admin")

  // Soft delete with FK to admin user
  deletedAt         DateTime? @map("deleted_at")
  deletedByUserId   String?   @map("deleted_by_user_id")

  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  wallet               Wallet?
  sessions             Session[]
  bankAccounts         BankAccount[]
  ordersInitiated      Order[]               @relation("OrderInitiator")
  ordersCounterparty   Order[]               @relation("OrderCounterparty")
  ordersDeleted        Order[]               @relation("OrderDeletedBy")
  ratingsGiven         Rating[]              @relation("RatingFrom")
  ratingsReceived      Rating[]              @relation("RatingTo")
  disputesOpened       Dispute[]             @relation("DisputeOpener")
  disputesArbitrated   Dispute[]             @relation("DisputeArbitrator")
  disputeEscalations   Dispute[]             @relation("DisputeEscalation")
  kycSubmissions       KYCSubmission[]       @relation("KYCUser")
  kycVerifications     KYCSubmission[]       @relation("KYCVerifier")
  payments             Payment[]
  orderComments        OrderComment[]
  auditLogs            AuditLog[]
  notifications        Notification[]
  disputeEvidences     DisputeEvidence[]
  withdrawalsRequested Withdrawal[]          @relation("WithdrawalRequester")
  withdrawalsApproved  Withdrawal[]          @relation("WithdrawalApprover")
  withdrawalReviews    Withdrawal[]          @relation("WithdrawalReviewer")
  withdrawalApprovals  WithdrawalApproval[]  @relation("WithdrawalApprovalUser")
  disputeTimelines     DisputeTimeline[]
  ratingModerations    Rating[]              @relation("RatingModerator")

  // User deletion actor relation (User deleted by another User)
  deletedByActions     User[]                @relation("DeletedBy")
  deletedBy            User?                 @relation("DeletedBy", fields: [deletedByUserId], references: [id], onDelete: SetNull)

  // Referral system
  referralCode         ReferralCode?
  referralsUsed        ReferralUsage[]       @relation("ReferredUser")
  referralsSent        ReferralUsage[]       @relation("ReferrerUser")
  referralRewards      ReferralReward[]

  // Promo & Voucher
  voucherUsages        VoucherUsage[]
  promoAssignments     PromoAssignment[]
  vouchersAssigned     Voucher[]             @relation("VoucherAssignedTo")

  // Activity Log
  activities           UserActivity[]

  // Transaction Limits
  transactionLimits    TransactionLimit[]    @relation("TransactionLimitUser")

  // Order Settlement (CRITICAL FIX)
  settlementsAsSeller  OrderSettlement[]     @relation("SettlementSeller")
  settlementsAsBuyer   OrderSettlement[]     @relation("SettlementBuyer")

  @@index([kycStatus])
  @@index([deletedAt])
  @@map("users")
}

model Session {
  id                  String    @id @default(uuid())
  userId              String    @map("user_id")
  refreshHash         String    @map("refresh_hash")
  userAgent           String?   @map("user_agent")
  ipAddress           String?   @map("ip_address")
  revokedAt           DateTime? @map("revoked_at")
  expiresAt           DateTime  @map("expires_at")
  createdAt           DateTime  @default(now()) @map("created_at")

  // Session rotation & token family
  sessionFamilyId     String?   @map("session_family_id")
  rotatedAt           DateTime? @map("rotated_at")
  replacedBySessionId String?   @map("replaced_by_session_id")

  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  replacedBy          Session?  @relation("SessionRotation", fields: [replacedBySessionId], references: [id], onDelete: SetNull)
  replacements        Session[] @relation("SessionRotation")

  @@index([userId, expiresAt])
  @@index([sessionFamilyId])
  @@map("sessions")
}

// ============================================================================
// WALLET & LEDGER MODELS (IMMUTABLE LEDGER)
// ============================================================================

model Wallet {
  id                String    @id @default(uuid())
  userId            String    @unique @map("user_id")
  currency          Currency  @default(IDR)

  // Cached balances (minor units) - must match ledger totals
  balanceMinor      BigInt    @default(0) @map("balance_minor") @db.BigInt
  lockedMinor       BigInt    @default(0) @map("locked_minor") @db.BigInt

  // Reconciliation tracking
  lastReconciledAt  DateTime? @map("last_reconciled_at")
  reconciliationHash String?  @map("reconciliation_hash")

  // Optimistic locking
  version           Int       @default(0) @map("version")

  // Soft delete (financial data should NOT be hard deleted)
  deletedAt         DateTime? @map("deleted_at")

  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  user              User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  accounts          LedgerAccount[]
  deposits          Deposit[]
  withdrawals       Withdrawal[]
  escrowHoldsBuyer  EscrowHold[] @relation("BuyerWallet")
  escrowHoldsSeller EscrowHold[] @relation("SellerWallet")

  @@index([userId])
  @@index([lastReconciledAt])
  @@map("wallets")
}

model LedgerAccount {
  id          String            @id @default(uuid())
  walletId    String?           @map("wallet_id")
  platformKey String?           @map("platform_key")
  type        LedgerAccountType
  currency    Currency          @default(IDR)
  createdAt   DateTime          @default(now()) @map("created_at")

  wallet      Wallet?           @relation(fields: [walletId], references: [id], onDelete: Restrict)
  entries     LedgerEntry[]

  // Note: Partial unique indexes MUST be created via raw SQL migration:
  // - Unique per (wallet_id, type, currency) when wallet_id IS NOT NULL
  // - Unique per (platform_key, type, currency) when platform_key IS NOT NULL
  // And XOR constraint ensures exactly one owner is set (wallet OR platform).

  @@index([walletId, type, currency])
  @@index([platformKey, type, currency])
  @@map("ledger_accounts")
}

model LedgerJournal {
  id               String      @id @default(uuid())
  type             JournalType
  currency         Currency    @default(IDR)
  amountMinor      BigInt      @map("amount_minor") @db.BigInt
  description      String
  idempotencyKey   String?     @unique @map("idempotency_key")
  createdAt        DateTime    @default(now()) @map("created_at")

  // Journal-centric links (single source of truth)
  // 1:1 links (unique) where entity produces exactly one journal.
  depositId         String? @unique @map("deposit_id")
  withdrawalId      String? @unique @map("withdrawal_id")
  disputeId         String? @unique @map("dispute_id")
  referralRewardId  String? @unique @map("referral_reward_id")
  voucherUsageId    String? @unique @map("voucher_usage_id")
  orderSettlementId String? @unique @map("order_settlement_id")

  // 1:N links (not unique) where entity may have multiple journals over time.
  orderId       String? @map("order_id")
  escrowHoldId  String? @map("escrow_hold_id")

  // Relations (named explicitly to avoid ambiguity)
  deposit         Deposit?         @relation("DepositJournal", fields: [depositId], references: [id], onDelete: Restrict)
  withdrawal      Withdrawal?      @relation("WithdrawalJournal", fields: [withdrawalId], references: [id], onDelete: Restrict)
  dispute         Dispute?         @relation("DisputeJournal", fields: [disputeId], references: [id], onDelete: Restrict)
  referralReward  ReferralReward?  @relation("ReferralRewardJournal", fields: [referralRewardId], references: [id], onDelete: Restrict)
  voucherUsage    VoucherUsage?    @relation("VoucherUsageJournal", fields: [voucherUsageId], references: [id], onDelete: Restrict)
  orderSettlement OrderSettlement? @relation("OrderSettlementJournal", fields: [orderSettlementId], references: [id], onDelete: Restrict)

  order          Order?       @relation("OrderJournals", fields: [orderId], references: [id], onDelete: Restrict)
  escrowHold     EscrowHold?  @relation("EscrowHoldJournals", fields: [escrowHoldId], references: [id], onDelete: Restrict)

  entries        LedgerEntry[]

  @@index([createdAt])
  @@index([type, createdAt])
  @@index([depositId])
  @@index([withdrawalId])
  @@index([disputeId])
  @@index([referralRewardId])
  @@index([voucherUsageId])
  @@index([orderSettlementId])
  @@index([orderId])
  @@index([escrowHoldId])
  @@index([orderId, createdAt])
  @@index([escrowHoldId, createdAt])
  @@map("ledger_journals")
}

model LedgerEntry {
  id                 String        @id @default(uuid())
  journalId          String        @map("journal_id")
  accountId          String        @map("account_id")
  amountMinor        BigInt        @map("amount_minor") @db.BigInt

  // Running balance for fast queries (ensure ordering by createdAt, id)
  runningBalanceMinor BigInt?      @map("running_balance_minor") @db.BigInt

  createdAt          DateTime      @default(now()) @map("created_at")

  journal            LedgerJournal @relation(fields: [journalId], references: [id], onDelete: Restrict)
  account            LedgerAccount @relation(fields: [accountId], references: [id], onDelete: Restrict)

  @@index([accountId, createdAt, id])
  @@index([accountId, journalId])
  @@index([journalId, createdAt])
  @@map("ledger_entries")
}

// ============================================================================
// PAYMENT MODELS
// ============================================================================

model Payment {
  id                String          @id @default(uuid())
  userId            String          @map("user_id")

  provider          PaymentProvider @default(XENDIT)
  providerInvoiceId String?         @unique @map("provider_invoice_id")

  paymentType       PaymentType     @map("payment_type")
  paymentMethod     PaymentMethod?  @map("payment_method")

  currency          Currency        @default(IDR)
  amountMinor       BigInt          @map("amount_minor") @db.BigInt

  status            PaymentStatus   @default(PENDING)
  paymentDetails    Json?           @map("payment_details")
  paidAt            DateTime?       @map("paid_at")
  createdAt         DateTime        @default(now()) @map("created_at")

  // Link to order if this payment is for order
  orderId           String?         @map("order_id")

  user              User            @relation(fields: [userId], references: [id], onDelete: Restrict)
  order             Order?          @relation(fields: [orderId], references: [id], onDelete: Restrict)
  deposit           Deposit?        @relation("PaymentDeposit")
  statusHistory     PaymentStatusHistory[]
  webhookEvents     WebhookEvent[]

  @@index([status, createdAt])
  @@index([userId])
  @@index([orderId])
  @@index([provider, providerInvoiceId])
  @@index([userId, createdAt])
  @@map("payments")
}

model PaymentStatusHistory {
  id             String         @id @default(uuid())
  paymentId      String         @map("payment_id")
  fromStatus     PaymentStatus? @map("from_status")
  toStatus       PaymentStatus  @map("to_status")
  changedAt      DateTime       @default(now()) @map("changed_at")
  changedBy      String?        @map("changed_by")
  reason         String?
  webhookEventId String?        @map("webhook_event_id")

  payment        Payment        @relation(fields: [paymentId], references: [id], onDelete: Restrict)

  @@index([paymentId, changedAt])
  @@index([webhookEventId])
  @@map("payment_status_history")
}

model WebhookEvent {
  id              String          @id @default(uuid())
  provider        PaymentProvider @default(XENDIT)
  eventId         String          @unique @map("event_id")
  eventType       String          @map("event_type")
  payload         Json

  status          WebhookStatus   @default(PENDING)
  retryCount      Int             @default(0) @map("retry_count")
  maxRetries      Int             @default(3) @map("max_retries")
  lastRetryAt     DateTime?       @map("last_retry_at")

  receivedAt      DateTime        @default(now()) @map("received_at")
  processedAt     DateTime?       @map("processed_at")
  processingError String?         @map("processing_error") @db.Text

  // Webhook entity linkage & security
  paymentId        String?   @map("payment_id")
  providerEventAt  DateTime? @map("provider_event_at")
  signatureValid   Boolean   @default(false) @map("signature_valid")
  signatureError   String?   @map("signature_error")

  payment          Payment?  @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@index([provider, receivedAt])
  @@index([status, retryCount])
  @@index([eventType])
  @@index([paymentId])
  @@map("webhook_events")
}

model Deposit {
  id          String        @id @default(uuid())
  walletId    String        @map("wallet_id")
  paymentId   String        @unique @map("payment_id")

  currency    Currency      @default(IDR)
  amountMinor BigInt        @map("amount_minor") @db.BigInt

  status      DepositStatus @default(PENDING)
  completedAt DateTime?     @map("completed_at")

  wallet      Wallet        @relation(fields: [walletId], references: [id], onDelete: Restrict)
  payment     Payment       @relation("PaymentDeposit", fields: [paymentId], references: [id], onDelete: Restrict)

  // Journal-centric: back relation (optional 1:1)
  journal     LedgerJournal? @relation("DepositJournal")

  @@index([walletId, status])
  @@map("deposits")
}

// ============================================================================
// BANK & WITHDRAWAL MODELS
// ============================================================================

model BankAccount {
  id                 String    @id @default(uuid())
  userId             String    @map("user_id")
  bankName           String    @map("bank_name")

  // Encrypted data
  accountNumberEnc   String    @map("account_number_enc") @db.Text
  accountNumberLast4 String    @map("account_number_last4")
  accountNameEnc     String    @map("account_name_enc") @db.Text
  keyVersion         Int       @default(1) @map("key_version")

  isDefault          Boolean   @default(false) @map("is_default")

  // Verification & status
  isActive           Boolean   @default(true) @map("is_active")
  isVerified         Boolean   @default(false) @map("is_verified")
  verifiedAt         DateTime? @map("verified_at")
  verificationMethod String?   @map("verification_method")
  lastUsedAt         DateTime? @map("last_used_at")

  deletedAt          DateTime? @map("deleted_at")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  user               User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  withdrawals        Withdrawal[]

  @@index([userId, isDefault])
  @@index([userId, isActive, isDefault])
  @@map("bank_accounts")
}

model Withdrawal {
  id                 String            @id @default(uuid())
  walletId           String            @map("wallet_id")
  userId             String            @map("user_id")
  bankAccountId      String            @map("bank_account_id")

  currency           Currency          @default(IDR)
  amountMinor        BigInt            @map("amount_minor") @db.BigInt

  status             WithdrawalStatus  @default(PENDING)

  // Review & approval workflow
  reviewedBy         String?           @map("reviewed_by")
  reviewStartedAt    DateTime?         @map("review_started_at")
  reviewNotes        String?           @map("review_notes") @db.Text

  adminNotes         String?           @map("admin_notes") @db.Text
  riskHoldUntil      DateTime?         @map("risk_hold_until")

  // Multi-approval for large amounts
  requiresMultipleApprovals Boolean    @default(false) @map("requires_multiple_approvals")
  approvalCount      Int               @default(0) @map("approval_count")
  requiredApprovals  Int               @default(1) @map("required_approvals")

  approvedBy         String?           @map("approved_by")
  approvedAt         DateTime?         @map("approved_at")
  rejectedAt         DateTime?         @map("rejected_at")

  // Provider disbursement
  providerDisbursementId String?       @map("provider_disbursement_id")

  requestedAt        DateTime          @default(now()) @map("requested_at")
  processedAt        DateTime?         @map("processed_at")

  // Idempotency
  idempotencyKey     String?           @unique @map("idempotency_key")

  wallet             Wallet            @relation(fields: [walletId], references: [id], onDelete: Restrict)
  user               User              @relation("WithdrawalRequester", fields: [userId], references: [id], onDelete: Restrict)
  bankAccount        BankAccount       @relation(fields: [bankAccountId], references: [id], onDelete: Restrict)
  approver           User?             @relation("WithdrawalApprover", fields: [approvedBy], references: [id], onDelete: SetNull)
  reviewer           User?             @relation("WithdrawalReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)
  approvals          WithdrawalApproval[]

  // Journal-centric: back relation (optional 1:1)
  journal            LedgerJournal?    @relation("WithdrawalJournal")

  @@index([status, requestedAt])
  @@index([walletId, requestedAt])
  @@index([requiresMultipleApprovals, approvalCount])
  @@index([userId, requestedAt])
  @@map("withdrawals")
}

model WithdrawalApproval {
  id            String     @id @default(uuid())
  withdrawalId  String     @map("withdrawal_id")
  approvedBy    String     @map("approved_by")
  notes         String?    @db.Text
  approvedAt    DateTime   @default(now()) @map("approved_at")

  withdrawal    Withdrawal @relation(fields: [withdrawalId], references: [id], onDelete: Cascade)
  approver      User       @relation("WithdrawalApprovalUser", fields: [approvedBy], references: [id], onDelete: Restrict)

  @@unique([withdrawalId, approvedBy])
  @@index([withdrawalId])
  @@map("withdrawal_approvals")
}

// ============================================================================
// ORDER & ESCROW MODELS
// ============================================================================

model Order {
  id                String        @id @default(uuid())
  orderNumber       String        @unique @map("order_number")

  initiatorId       String        @map("initiator_id")
  counterpartyId    String?       @map("counterparty_id")
  initiatorRole     InitiatorRole @map("initiator_role")

  title             String
  description       String        @db.Text
  category          OrderCategory

  currency          Currency      @default(IDR)
  amountMinor       BigInt        @map("amount_minor") @db.BigInt

  feePayer          FeePayer      @map("fee_payer")
  platformFeeMinor  BigInt        @map("platform_fee_minor") @db.BigInt

  holdingPeriodDays Int           @map("holding_period_days")
  customTerms       String?       @map("custom_terms") @db.Text

  status            OrderStatus   @default(PENDING_ACCEPT)

  inviteToken       String        @unique @map("invite_token")
  inviteExpiresAt   DateTime      @map("invite_expires_at")

  acceptedAt        DateTime?     @map("accepted_at")
  paidAt            DateTime?     @map("paid_at")
  autoReleaseAt     DateTime?     @map("auto_release_at")
  completedAt       DateTime?     @map("completed_at")
  cancelledAt       DateTime?     @map("cancelled_at")

  // Soft delete with FK
  deletedAt         DateTime?     @map("deleted_at")
  deletedByUserId   String?       @map("deleted_by_user_id")

  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  // Relations
  initiator         User          @relation("OrderInitiator", fields: [initiatorId], references: [id], onDelete: Restrict)
  counterparty      User?         @relation("OrderCounterparty", fields: [counterpartyId], references: [id], onDelete: Restrict)
  deletedByUser     User?         @relation("OrderDeletedBy", fields: [deletedByUserId], references: [id], onDelete: SetNull)

  escrowHold        EscrowHold?
  settlement        OrderSettlement?
  deliveryProof     DeliveryProof?
  dispute           Dispute?
  ratings           Rating[]
  comments          OrderComment[]
  payments          Payment[]

  // Journal-centric: order can have multiple journals across lifecycle
  journals          LedgerJournal[] @relation("OrderJournals")

  @@index([status])
  @@index([inviteToken])
  @@index([autoReleaseAt])
  @@index([inviteExpiresAt])
  @@index([status, autoReleaseAt])
  @@map("orders")
}

model EscrowHold {
  id             String           @id @default(uuid())
  orderId        String           @unique @map("order_id")

  buyerWalletId  String           @map("buyer_wallet_id")
  sellerWalletId String?          @map("seller_wallet_id")

  currency       Currency         @default(IDR)
  amountMinor    BigInt           @map("amount_minor") @db.BigInt

  status         EscrowHoldStatus @default(ACTIVE)
  createdAt      DateTime         @default(now()) @map("created_at")
  resolvedAt     DateTime?        @map("resolved_at")

  order          Order            @relation(fields: [orderId], references: [id], onDelete: Restrict)
  buyerWallet    Wallet           @relation("BuyerWallet", fields: [buyerWalletId], references: [id], onDelete: Restrict)
  sellerWallet   Wallet?          @relation("SellerWallet", fields: [sellerWalletId], references: [id], onDelete: Restrict)

  // Journal-centric: escrow hold lifecycle journals (hold/release/refund/fee/adjustment)
  journals       LedgerJournal[]  @relation("EscrowHoldJournals")

  @@index([status, createdAt])
  @@index([buyerWalletId])
  @@index([sellerWalletId])
  @@map("escrow_holds")
}

model OrderSettlement {
  id                String    @id @default(uuid())
  orderId           String    @unique @map("order_id")

  currency          Currency  @default(IDR)
  sellerUserId      String    @map("seller_user_id")
  buyerUserId       String    @map("buyer_user_id")

  sellerAmountMinor BigInt    @map("seller_amount_minor") @db.BigInt
  buyerRefundMinor  BigInt    @map("buyer_refund_minor") @db.BigInt
  platformFeeMinor  BigInt    @map("platform_fee_minor") @db.BigInt

  settledAt         DateTime  @default(now()) @map("settled_at")

  order             Order     @relation(fields: [orderId], references: [id], onDelete: Restrict)
  seller            User      @relation("SettlementSeller", fields: [sellerUserId], references: [id], onDelete: Restrict)
  buyer             User      @relation("SettlementBuyer", fields: [buyerUserId], references: [id], onDelete: Restrict)

  // Journal-centric: optional 1:1 journal for settlement posting/traceability
  journal           LedgerJournal? @relation("OrderSettlementJournal")

  @@index([orderId])
  @@index([sellerUserId])
  @@index([buyerUserId])
  @@map("order_settlements")
}

model DeliveryProof {
  id             String    @id @default(uuid())
  orderId        String    @unique @map("order_id")
  courier        String?
  trackingNumber String?   @map("tracking_number")
  fileUrls       Json      @map("file_urls")
  notes          String    @db.Text
  submittedAt    DateTime  @default(now()) @map("submitted_at")

  order          Order     @relation(fields: [orderId], references: [id], onDelete: Restrict)

  @@map("delivery_proofs")
}

// ============================================================================
// DISPUTE MODELS
// ============================================================================

model Dispute {
  id               String          @id @default(uuid())
  orderId          String          @unique @map("order_id")
  openedBy         String          @map("opened_by")
  reason           String          @db.Text

  status           DisputeStatus   @default(OPEN)

  // Response & escalation tracking
  responseDeadline DateTime?       @map("response_deadline")
  escalatedAt      DateTime?       @map("escalated_at")
  escalatedTo      String?         @map("escalated_to")

  arbitratorId     String?         @map("arbitrator_id")
  decision         DisputeDecision @default(NONE)

  sellerAmountMinor BigInt?        @map("seller_amount_minor") @db.BigInt
  buyerRefundMinor  BigInt?        @map("buyer_refund_minor") @db.BigInt

  adminNotes       String?         @map("admin_notes") @db.Text
  resolutionNotes  String?         @map("resolution_notes") @db.Text

  // Appeal mechanism
  canAppeal        Boolean         @default(true) @map("can_appeal")
  appealDeadline   DateTime?       @map("appeal_deadline")
  appealCount      Int             @default(0) @map("appeal_count")

  openedAt         DateTime        @default(now()) @map("opened_at")
  decidedAt        DateTime?       @map("decided_at")

  order            Order           @relation(fields: [orderId], references: [id], onDelete: Restrict)
  opener           User            @relation("DisputeOpener", fields: [openedBy], references: [id], onDelete: Restrict)
  arbitrator       User?           @relation("DisputeArbitrator", fields: [arbitratorId], references: [id], onDelete: SetNull)
  escalatedToUser  User?           @relation("DisputeEscalation", fields: [escalatedTo], references: [id], onDelete: SetNull)
  evidences        DisputeEvidence[]
  timeline         DisputeTimeline[]

  // Journal-centric: back relation (optional 1:1)
  journal          LedgerJournal?  @relation("DisputeJournal")

  @@index([status])
  @@index([responseDeadline])
  @@index([appealDeadline])
  @@map("disputes")
}

model DisputeEvidence {
  id           String    @id @default(uuid())
  disputeId    String    @map("dispute_id")
  submittedBy  String    @map("submitted_by")
  fileUrls     Json      @map("file_urls")
  description  String    @db.Text
  submittedAt  DateTime  @default(now()) @map("submitted_at")

  dispute      Dispute   @relation(fields: [disputeId], references: [id], onDelete: Restrict)
  submitter    User      @relation(fields: [submittedBy], references: [id], onDelete: Restrict)

  @@index([disputeId, submittedAt])
  @@map("dispute_evidence")
}

model DisputeTimeline {
  id          String   @id @default(uuid())
  disputeId   String   @map("dispute_id")
  action      String
  performedBy String?  @map("performed_by")
  details     Json?
  createdAt   DateTime @default(now()) @map("created_at")

  dispute     Dispute  @relation(fields: [disputeId], references: [id], onDelete: Restrict)
  user        User?    @relation(fields: [performedBy], references: [id], onDelete: SetNull)

  @@index([disputeId, createdAt])
  @@map("dispute_timeline")
}

// ============================================================================
// RATING & REVIEW MODELS
// ============================================================================

model Rating {
  id          String    @id @default(uuid())
  orderId     String    @map("order_id")
  fromUserId  String    @map("from_user_id")
  toUserId    String    @map("to_user_id")

  // Rating constrained 1-5 (enforce in application + DB check constraint)
  rating      Int
  reviewText  String?   @map("review_text") @db.Text

  // Verification & moderation
  isVerifiedPurchase Boolean   @default(true) @map("is_verified_purchase")
  helpfulCount       Int       @default(0) @map("helpful_count")
  reportedCount      Int       @default(0) @map("reported_count")
  isHidden           Boolean   @default(false) @map("is_hidden")
  moderatedAt        DateTime? @map("moderated_at")
  moderatedBy        String?   @map("moderated_by")

  createdAt   DateTime  @default(now()) @map("created_at")

  order       Order     @relation(fields: [orderId], references: [id], onDelete: Restrict)
  fromUser    User      @relation("RatingFrom", fields: [fromUserId], references: [id], onDelete: Restrict)
  toUser      User      @relation("RatingTo", fields: [toUserId], references: [id], onDelete: Restrict)
  moderator   User?     @relation("RatingModerator", fields: [moderatedBy], references: [id], onDelete: SetNull)

  @@unique([orderId, fromUserId])
  @@index([toUserId, createdAt])
  @@index([isHidden, reportedCount])
  @@map("ratings")
}

// ============================================================================
// KYC MODELS
// ============================================================================

model KYCSubmission {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")

  // Object storage keys
  idCardObjectKey String    @map("id_card_object_key")
  selfieObjectKey String    @map("selfie_object_key")

  // Document integrity
  idCardHash      String    @map("id_card_hash")
  selfieHash      String    @map("selfie_hash")

  // Encrypted personal data
  fullNameEnc     String    @map("full_name_enc") @db.Text
  idNumberEnc     String    @map("id_number_enc") @db.Text
  dateOfBirthEnc  String    @map("date_of_birth_enc") @db.Text
  addressEnc      String    @map("address_enc") @db.Text
  keyVersion      Int       @default(1) @map("key_version")

  status          KYCStatus @default(PENDING)

  // Attempt tracking & expiry
  attemptNumber   Int       @default(1) @map("attempt_number")
  expiresAt       DateTime? @map("expires_at")

  rejectionReason String?   @map("rejection_reason") @db.Text
  verifiedBy      String?   @map("verified_by")
  submittedAt     DateTime  @default(now()) @map("submitted_at")
  verifiedAt      DateTime? @map("verified_at")

  user            User      @relation("KYCUser", fields: [userId], references: [id], onDelete: Restrict)
  verifier        User?     @relation("KYCVerifier", fields: [verifiedBy], references: [id], onDelete: SetNull)

  @@index([status, submittedAt])
  @@index([userId, attemptNumber])
  @@index([expiresAt])
  @@map("kyc_submissions")
}

// ============================================================================
// REFERRAL SYSTEM
// ============================================================================

model ReferralCode {
  id         String    @id @default(uuid())
  userId     String    @unique @map("user_id")
  code       String    @unique

  // Usage tracking
  usageCount Int       @default(0) @map("usage_count")
  maxUsages  Int?      @map("max_usages")

  isActive   Boolean   @default(true) @map("is_active")
  expiresAt  DateTime? @map("expires_at")

  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  user       User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  usages     ReferralUsage[]

  @@index([isActive, expiresAt])
  @@map("referral_codes")
}

model ReferralUsage {
  id             String         @id @default(uuid())
  referralCodeId String         @map("referral_code_id")
  referrerId     String         @map("referrer_id")
  referredUserId String         @map("referred_user_id")

  status         ReferralStatus @default(PENDING)

  // Completion criteria
  requiredAction String?        @map("required_action")
  completedAt    DateTime?      @map("completed_at")
  expiresAt      DateTime?      @map("expires_at")

  usedAt         DateTime       @default(now()) @map("used_at")

  referralCode   ReferralCode   @relation(fields: [referralCodeId], references: [id], onDelete: Restrict)
  referrer       User           @relation("ReferrerUser", fields: [referrerId], references: [id], onDelete: Restrict)
  referredUser   User           @relation("ReferredUser", fields: [referredUserId], references: [id], onDelete: Restrict)
  rewards        ReferralReward[]

  @@unique([referralCodeId, referredUserId])
  @@index([referrerId, status])
  @@index([referredUserId])
  @@index([status, completedAt])
  @@map("referral_usages")
}

model ReferralReward {
  id              String               @id @default(uuid())
  referralUsageId String               @map("referral_usage_id")
  userId          String               @map("user_id")

  rewardType      ReferralRewardType   @map("reward_type")
  currency        Currency             @default(IDR)
  amountMinor     BigInt               @map("amount_minor") @db.BigInt

  // Reward metadata
  tier            Int?
  description     String?              @db.Text

  status          ReferralRewardStatus  @default(PENDING)
  processedAt     DateTime?            @map("processed_at")
  expiresAt       DateTime?            @map("expires_at")

  createdAt       DateTime             @default(now()) @map("created_at")

  // Idempotency
  idempotencyKey  String?              @unique @map("idempotency_key")

  referralUsage   ReferralUsage        @relation(fields: [referralUsageId], references: [id], onDelete: Restrict)
  user            User                 @relation(fields: [userId], references: [id], onDelete: Restrict)

  // Journal-centric: back relation (optional 1:1)
  journal         LedgerJournal?       @relation("ReferralRewardJournal")

  @@index([userId, status])
  @@index([referralUsageId])
  @@index([expiresAt])
  @@map("referral_rewards")
}

// ============================================================================
// PROMO & VOUCHER SYSTEM
// ============================================================================

model Promo {
  id                 String          @id @default(uuid())
  code               String          @unique
  name               String
  description        String?         @db.Text

  targetType         PromoTargetType @map("target_type")

  // Discount configuration
  discountType       VoucherType     @map("discount_type")
  discountValue      BigInt?         @map("discount_value") @db.BigInt
  discountPercent    Decimal?        @map("discount_percent") @db.Decimal(5, 2)
  maxDiscountMinor   BigInt?         @map("max_discount_minor") @db.BigInt

  // Usage limits
  maxTotalUsages     Int?            @map("max_total_usages")
  maxUsagePerUser    Int             @default(1) @map("max_usage_per_user")
  currentUsages      Int             @default(0) @map("current_usages")

  // Constraints
  minPurchaseMinor   BigInt?         @map("min_purchase_minor") @db.BigInt
  applicableCategories Json?         @map("applicable_categories")

  // Validity
  validFrom          DateTime        @map("valid_from")
  validUntil         DateTime        @map("valid_until")

  isActive           Boolean         @default(true) @map("is_active")
  createdAt          DateTime        @default(now()) @map("created_at")
  updatedAt          DateTime        @updatedAt @map("updated_at")

  assignments        PromoAssignment[]
  vouchers           Voucher[]

  @@index([isActive, validFrom, validUntil])
  @@index([targetType])
  @@map("promos")
}

model PromoAssignment {
  id          String   @id @default(uuid())
  promoId     String   @map("promo_id")
  userId      String   @map("user_id")

  assignedAt  DateTime @default(now()) @map("assigned_at")
  expiresAt   DateTime? @map("expires_at")

  promo       Promo    @relation(fields: [promoId], references: [id], onDelete: Restrict)
  user        User     @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@unique([promoId, userId])
  @@index([userId])
  @@index([promoId])
  @@map("promo_assignments")
}

model Voucher {
  id               String        @id @default(uuid())
  promoId          String?       @map("promo_id")
  code             String        @unique

  voucherType      VoucherType   @map("voucher_type")

  // Value configuration
  currency         Currency      @default(IDR)
  discountMinor    BigInt?       @map("discount_minor") @db.BigInt
  discountPercent  Decimal?      @map("discount_percent") @db.Decimal(5, 2)
  maxDiscountMinor BigInt?       @map("max_discount_minor") @db.BigInt

  // Usage limits
  maxUsages        Int           @default(1) @map("max_usages")
  currentUsages    Int           @default(0) @map("current_usages")

  // Constraints
  minPurchaseMinor BigInt?       @map("min_purchase_minor") @db.BigInt
  applicableCategories Json?     @map("applicable_categories")

  // Validity
  validFrom        DateTime      @map("valid_from")
  validUntil       DateTime      @map("valid_until")

  status           VoucherStatus @default(ACTIVE)

  // Assignment (optional - for user-specific vouchers)
  assignedToUserId String?       @map("assigned_to_user_id")

  createdAt         DateTime     @default(now()) @map("created_at")
  updatedAt         DateTime     @updatedAt @map("updated_at")

  promo            Promo?        @relation(fields: [promoId], references: [id], onDelete: SetNull)
  assignedToUser   User?         @relation("VoucherAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)
  usages           VoucherUsage[]

  @@index([status, validFrom, validUntil])
  @@index([assignedToUserId])
  @@map("vouchers")
}

model VoucherUsage {
  id            String    @id @default(uuid())
  voucherId     String    @map("voucher_id")
  userId        String    @map("user_id")
  orderId       String?   @map("order_id")

  currency      Currency  @default(IDR)
  originalMinor BigInt    @map("original_minor") @db.BigInt
  discountMinor BigInt    @map("discount_minor") @db.BigInt
  finalMinor    BigInt    @map("final_minor") @db.BigInt

  usedAt        DateTime  @default(now()) @map("used_at")

  // Idempotency
  idempotencyKey String?  @unique @map("idempotency_key")

  voucher       Voucher   @relation(fields: [voucherId], references: [id], onDelete: Restrict)
  user          User      @relation(fields: [userId], references: [id], onDelete: Restrict)

  // Journal-centric: back relation (optional 1:1)
  journal       LedgerJournal? @relation("VoucherUsageJournal")

  @@index([voucherId, usedAt])
  @@index([userId])
  @@map("voucher_usages")
}

// ============================================================================
// ACTIVITY LOG
// ============================================================================

model UserActivity {
  id           String       @id @default(uuid())
  userId       String       @map("user_id")

  activityType ActivityType @map("activity_type")
  description  String?
  metadata     Json?

  ipAddress    String?      @map("ip_address")
  userAgent    String?      @map("user_agent")
  deviceId     String?      @map("device_id")

  // Geolocation (optional)
  country      String?
  city         String?

  createdAt    DateTime     @default(now()) @map("created_at")

  user         User         @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([userId, createdAt])
  @@index([activityType, createdAt])
  @@index([createdAt])
  @@map("user_activities")
}

// ============================================================================
// NOTIFICATION & COMMUNICATION
// ============================================================================

model OrderComment {
  id          String   @id @default(uuid())
  orderId     String   @map("order_id")
  userId      String   @map("user_id")
  message     String   @db.Text
  attachments Json?
  createdAt   DateTime @default(now()) @map("created_at")

  order       Order    @relation(fields: [orderId], references: [id], onDelete: Restrict)
  user        User     @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([orderId, createdAt])
  @@map("order_comments")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  type      String
  title     String
  message   String   @db.Text
  metadata  Json?
  readAt    DateTime? @map("read_at")
  createdAt DateTime @default(now()) @map("created_at")

  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@index([userId, readAt])
  @@index([userId, createdAt])
  @@map("notifications")
}

// ============================================================================
// AUDIT & COMPLIANCE
// ============================================================================

model AuditLog {
  id          String   @id @default(uuid())
  action      String
  performedBy String?  @map("performed_by")
  entityType  String   @map("entity_type")
  entityId    String?  @map("entity_id")
  details     Json
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at")

  // Tamper-evidence chain
  rowHash       String? @map("row_hash")
  prevHash      String? @map("prev_hash")
  correlationId String? @map("correlation_id")

  user        User?    @relation(fields: [performedBy], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([performedBy, createdAt])
  @@index([correlationId])
  @@map("audit_logs")
}

// ============================================================================
// SYSTEM CONFIGURATION
// ============================================================================

model SystemConfig {
  id          String   @id @default(uuid())
  key         String   @unique
  value       Json
  description String?  @db.Text
  isActive    Boolean  @default(true) @map("is_active")
  updatedAt   DateTime @updatedAt @map("updated_at")
  createdAt   DateTime @default(now()) @map("created_at")

  @@index([key, isActive])
  @@map("system_configs")
}

model TransactionLimit {
  id                       String    @id @default(uuid())
  userId                   String?   @map("user_id")
  kycStatus                KYCStatus @default(NONE) @map("kyc_status")

  currency                 Currency  @default(IDR)

  // Limits in minor units (non-negative, enforce in application + DB)
  dailyLimitMinor          BigInt    @map("daily_limit_minor") @db.BigInt
  perTxLimitMinor          BigInt    @map("per_tx_limit_minor") @db.BigInt
  monthlyLimitMinor        BigInt?   @map("monthly_limit_minor") @db.BigInt
  dailyWithdrawalLimitMinor BigInt?  @map("daily_withdrawal_limit_minor") @db.BigInt

  effectiveFrom            DateTime  @map("effective_from")
  effectiveUntil           DateTime? @map("effective_until")

  isActive                 Boolean   @default(true) @map("is_active")
  createdAt                DateTime  @default(now()) @map("created_at")

  user                     User?     @relation("TransactionLimitUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, isActive])
  @@index([kycStatus, isActive])
  @@map("transaction_limits")
}

model FeeConfig {
  id             String        @id @default(uuid())
  name           String
  orderCategory  OrderCategory?

  // Fee structure (non-negative values, enforce in application + DB)
  minAmountMinor BigInt?       @map("min_amount_minor") @db.BigInt
  maxAmountMinor BigInt?       @map("max_amount_minor") @db.BigInt
  feePercentage  Decimal       @db.Decimal(5, 4) @map("fee_percentage")
  flatFeeMinor   BigInt        @default(0) @map("flat_fee_minor") @db.BigInt

  currency       Currency      @default(IDR)

  effectiveFrom  DateTime      @map("effective_from")
  effectiveUntil DateTime?     @map("effective_until")

  isActive       Boolean       @default(true) @map("is_active")
  priority       Int           @default(0)

  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")

  @@index([orderCategory, isActive])
  @@index([effectiveFrom, effectiveUntil])
  @@map("fee_configs")
}

model PlatformAccountKey {
  key         String            @id
  description String
  accountType LedgerAccountType @map("account_type")
  isActive    Boolean           @default(true) @map("is_active")
  createdAt   DateTime          @default(now()) @map("created_at")

  @@map("platform_account_keys")
}

// ============================================================================
// SCHEDULED JOBS & AUTOMATION
// ============================================================================

model ScheduledJob {
  id           String             @id @default(uuid())
  jobType       String             @map("job_type")
  entityType    String?            @map("entity_type")
  entityId      String?            @map("entity_id")

  scheduledAt   DateTime           @map("scheduled_at")
  executedAt    DateTime?          @map("executed_at")

  status        ScheduledJobStatus  @default(PENDING)
  retryCount    Int                @default(0) @map("retry_count")
  maxRetries    Int                @default(3) @map("max_retries")

  payload       Json?
  result        Json?
  errorMessage  String?            @map("error_message") @db.Text

  createdAt     DateTime           @default(now()) @map("created_at")

  // Idempotency
  idempotencyKey String?           @map("idempotency_key")

  @@index([jobType, status, scheduledAt])
  @@index([scheduledAt, status])
  @@index([entityType, entityId])
  @@map("scheduled_jobs")
}
