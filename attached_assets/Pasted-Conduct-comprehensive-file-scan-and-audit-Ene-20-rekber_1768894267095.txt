Conduct comprehensive file scan and audit
Ene 20
¬∑
rekberkan/kahad
¬∑
main

I-archive

Ibahagi

1
scan & audit menyeluruh secara details setiap filenya! Harus BENAR BENAR tidak ada error, missing, bug, atau sejenisnya. Anda hanya perlu scan & audit lalu Berikan semua nya kesaya biar saya perbaiki sendiri. Fokus pada scan Dan audit seluruh file saja. Sampai anda tidak menemukan bug, error, missing, dll. Ingat harus konsisten, terintegrasi, terstruktur sesuai dengan schema proyek ini. 

Ingat KEAMANAN No 1 Karena ini proyek keuangan!
Kopyahin
Di bawah ini adalah hasil scan & audit menyeluruh yang saya lakukan berdasarkan peninjauan file dan pencarian pola risiko keamanan/bug. Karena ini proyek finansial, saya fokus pada isu keamanan, konsistensi skema, dan potensi bug operasional. Saya tidak melakukan perubahan kode apa pun (hanya audit).

Metodologi Singkat (Audit)
Saya menelusuri struktur repo dan memeriksa file kunci (konfigurasi, auth, storage, prisma schema, seed data, middleware) serta melakukan pencarian pola TODO dan isu keamanan umum. Temuan di bawah ini didasarkan pada file yang terbaca langsung di repo. Saya tidak menjalankan aplikasi/test (tidak diminta).

üîé Temuan Audit (Prioritas Tinggi ‚Üí Rendah)
üö® CRITICAL / HIGH SECURITY
1) Refresh token + blacklist disimpan di memori (non-persisten, tidak terdistribusi)
Dampak:

Logout/blacklist hanya berlaku di instance yang sama.

Setelah restart, semua token kembali valid.

Tidak aman untuk sistem finansial dan cluster/multi-instance.
Bukti: TokenBlacklistService hanya menggunakan Set/Map memori lokal dan cleanup via setTimeout tanpa storage persisten.
Di AuthService, komentar menyebut Redis, tetapi yang digunakan tetap service in-memory tersebut, sehingga implementasinya tidak sesuai desain keamanan yang tertulis.

2) Risiko Path Traversal & File Overwrite pada Upload/Download
Dampak:

file.originalname langsung dipakai dalam path ‚Üí memungkinkan attacker memasukkan ../ untuk menulis file di luar folder upload.

delete() dan get() juga menerima filename tanpa sanitasi ‚Üí dapat menghapus/akses file arbitrer.
Bukti: file path dibentuk dari file.originalname dan filename tanpa validasi/normalisasi tambahan.

3) Exception Filter mengembalikan pesan error mentah
Dampak:

Jika terjadi error tak terduga (non-HttpException), exception.message dikirim ke client.

Bisa membocorkan detail internal/stack trace sensitif di lingkungan produksi.
Bukti: penggunaan exception.message langsung pada response error.

4) Dockerfile dev kosong (TODO)
Dampak:

Build/dev container akan gagal total; ini bisa memblokir workflow CI/dev.
Bukti: file Dockerfile.dev hanya berisi TODO tanpa instruksi Docker valid.

‚ö†Ô∏è HIGH / MEDIUM RISK
5) Rate limiting tidak terpasang walau konfigurasi ada
Dampak:

Tidak ada throttling global pada endpoint kritikal (login, register, refresh, dll).

Risiko brute-force & abuse meningkat.
Bukti: rateLimitConfig didefinisikan tetapi ThrottlerModule tidak diimpor di AppModule.

6) Session schema tersedia, tetapi tidak digunakan di auth flow
Dampak:

Skema Session (refreshHash, sessionFamilyId, rotation) tidak diintegrasikan; refresh token hanya disimpan di memory, bukan DB.

Hilangnya audit trail/session rotation yang diperlukan sistem finansial.
Bukti: model Session ada di Prisma schema, namun AuthService tidak menulis/validasi session DB tersebut.

üü° MEDIUM / LOW RISK / KONSISTENSI
7) Seed data menggunakan field password yang tidak sesuai schema (passwordHash)
Dampak:

Seed data bisa gagal atau mengarah ke penyimpanan password mentah jika ada pipeline yang mengeksekusi file JSON ini.
Bukti: file seed JSON memakai key password, sementara schema User hanya memiliki passwordHash.

8) Password hardcoded pada seed script Prisma
Dampak:

Jika seed dijalankan di lingkungan non-dev, akun default bisa terbentuk dengan password lemah yang sama.
Bukti: password hardcoded admin123456 untuk semua user seed.

9) CORS default * di konfigurasi app
Dampak:

Di non-production environment, aplikasi bisa berjalan dengan origin: * + credentials: true, yang tidak aman bila server terekspos publik.

Meskipun main.ts mengunci di production, tetap berisiko di staging/QA yang terbuka.
Bukti: default corsOrigin adalah * di config, dan main.ts hanya memblokir ini di production.

‚úÖ Catatan Positif / Mitigasi yang Sudah Ada
Validasi global ValidationPipe sudah diaktifkan (whitelist + forbid non-whitelisted).

JWT secrets dipaksa di production melalui jwt.config.ts (fail fast).

Database config menolak DATABASE_URL kosong di production dan memperingatkan kredensial default.

Perintah Audit yang Saya Jalankan
Berikut perintah yang saya gunakan untuk memindai repo (ditampilkan untuk transparansi):

rg -n "TODO|FIXME|HACK|BUG" /workspace/kahade/kahade-backend

rg -n "(password|secret|token|api[_-]?key|private[_-]?key|secret[_-]?key)" /workspace/kahade/kahade-backend/...

rg -n "\\beval\\(|\\bexec\\(|child_process|spawn\\(|\\bFunction\\(|deserialize|serialize\\(|unsafe|csrf|xss|sql injection|injection" /workspace/kahade/kahade-backend/src

(Temuan dari perintah tersebut kemudian diverifikasi langsung pada file terkait dengan bukti dan lokasi baris sebagaimana disitasi di atas.)

Penutup
Saya sudah melakukan audit secara menyeluruh dan mencatat seluruh masalah yang terlihat jelas pada file-file yang ditinjau. Saya tidak bisa menjamin ‚Äútidak ada bug sama sekali‚Äù tanpa eksekusi runtime/test dan threat modeling lebih lanjut, tetapi temuan di atas adalah isu struktural dan keamanan paling nyata dari hasil scan statik.